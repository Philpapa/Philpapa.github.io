import{g as mt}from"./_@antv_x6-common@2.0.17@@antv-5f61d1c3.js";var k;(function(d){function t(n){return 180*n/Math.PI%360}d.toDeg=t,d.toRad=function(n,s=!1){return(s?n:n%360)*Math.PI/180};function e(n){return n%360+(n<0?360:0)}d.normalize=e})(k||(k={}));var D;(function(d){function t(o,c=0){return Number.isInteger(o)?o:+o.toFixed(c)}d.round=t;function e(o,c){let h,a;if(c==null?(a=o==null?1:o,h=0):(a=c,h=o==null?0:o),a<h){const u=h;h=a,a=u}return Math.floor(Math.random()*(a-h+1)+h)}d.random=e;function n(o,c,h){return Number.isNaN(o)?NaN:Number.isNaN(c)||Number.isNaN(h)?0:c<h?o<c?c:o>h?h:o:o<h?h:o>c?c:o}d.clamp=n;function s(o,c){return c*Math.round(o/c)}d.snapToGrid=s;function i(o,c){return c!=null&&o!=null&&c.x>=o.x&&c.x<=o.x+o.width&&c.y>=o.y&&c.y<=o.y+o.height}d.containsPoint=i;function r(o,c){const h=o.x-c.x,a=o.y-c.y;return h*h+a*a}d.squaredLength=r})(D||(D={}));class F{valueOf(){return this.toJSON()}toString(){return JSON.stringify(this.toJSON())}}class g extends F{constructor(t,e){super(),this.x=t==null?0:t,this.y=e==null?0:e}round(t=0){return this.x=D.round(this.x,t),this.y=D.round(this.y,t),this}add(t,e){const n=g.create(t,e);return this.x+=n.x,this.y+=n.y,this}update(t,e){const n=g.create(t,e);return this.x=n.x,this.y=n.y,this}translate(t,e){const n=g.create(t,e);return this.x+=n.x,this.y+=n.y,this}rotate(t,e){const n=g.rotate(this,t,e);return this.x=n.x,this.y=n.y,this}scale(t,e,n=new g){const s=g.create(n);return this.x=s.x+t*(this.x-s.x),this.y=s.y+e*(this.y-s.y),this}closest(t){if(t.length===1)return g.create(t[0]);let e=null,n=1/0;return t.forEach(s=>{const i=this.squaredDistance(s);i<n&&(e=s,n=i)}),e?g.create(e):null}distance(t){return Math.sqrt(this.squaredDistance(t))}squaredDistance(t){const e=g.create(t),n=this.x-e.x,s=this.y-e.y;return n*n+s*s}manhattanDistance(t){const e=g.create(t);return Math.abs(e.x-this.x)+Math.abs(e.y-this.y)}magnitude(){return Math.sqrt(this.x*this.x+this.y*this.y)||.01}theta(t=new g){const e=g.create(t),n=-(e.y-this.y),s=e.x-this.x;let i=Math.atan2(n,s);return i<0&&(i=2*Math.PI+i),180*i/Math.PI}angleBetween(t,e){if(this.equals(t)||this.equals(e))return NaN;let n=this.theta(e)-this.theta(t);return n<0&&(n+=360),n}vectorAngle(t){return new g(0,0).angleBetween(this,t)}toPolar(t){return this.update(g.toPolar(this,t)),this}changeInAngle(t,e,n=new g){return this.clone().translate(-t,-e).theta(n)-this.theta(n)}adhereToRect(t){return D.containsPoint(t,this)||(this.x=Math.min(Math.max(this.x,t.x),t.x+t.width),this.y=Math.min(Math.max(this.y,t.y),t.y+t.height)),this}bearing(t){const e=g.create(t),n=k.toRad(this.y),s=k.toRad(e.y),i=this.x,r=e.x,o=k.toRad(r-i),c=Math.sin(o)*Math.cos(s),h=Math.cos(n)*Math.sin(s)-Math.sin(n)*Math.cos(s)*Math.cos(o),a=k.toDeg(Math.atan2(c,h)),u=["NE","E","SE","S","SW","W","NW","N"];let l=a-22.5;return l<0&&(l+=360),l=parseInt(l/45,10),u[l]}cross(t,e){if(t!=null&&e!=null){const n=g.create(t),s=g.create(e);return(s.x-this.x)*(n.y-this.y)-(s.y-this.y)*(n.x-this.x)}return NaN}dot(t){const e=g.create(t);return this.x*e.x+this.y*e.y}diff(t,e){if(typeof t=="number")return new g(this.x-t,this.y-e);const n=g.create(t);return new g(this.x-n.x,this.y-n.y)}lerp(t,e){const n=g.create(t);return new g((1-e)*this.x+e*n.x,(1-e)*this.y+e*n.y)}normalize(t=1){const e=t/this.magnitude();return this.scale(e,e)}move(t,e){const n=g.create(t),s=k.toRad(n.theta(this));return this.translate(Math.cos(s)*e,-Math.sin(s)*e)}reflection(t){return g.create(t).move(this,this.distance(t))}snapToGrid(t,e){return this.x=D.snapToGrid(this.x,t),this.y=D.snapToGrid(this.y,e==null?t:e),this}equals(t){const e=g.create(t);return e!=null&&e.x===this.x&&e.y===this.y}clone(){return g.clone(this)}toJSON(){return g.toJSON(this)}serialize(){return`${this.x} ${this.y}`}}(function(d){function t(e){return e!=null&&e instanceof d}d.isPoint=t})(g||(g={}));(function(d){function t(n){return n!=null&&typeof n=="object"&&typeof n.x=="number"&&typeof n.y=="number"}d.isPointLike=t;function e(n){return n!=null&&Array.isArray(n)&&n.length===2&&typeof n[0]=="number"&&typeof n[1]=="number"}d.isPointData=e})(g||(g={}));(function(d){function t(u,l){return u==null||typeof u=="number"?new d(u,l):e(u)}d.create=t;function e(u){return d.isPoint(u)?new d(u.x,u.y):Array.isArray(u)?new d(u[0],u[1]):new d(u.x,u.y)}d.clone=e;function n(u){return d.isPoint(u)?{x:u.x,y:u.y}:Array.isArray(u)?{x:u[0],y:u[1]}:{x:u.x,y:u.y}}d.toJSON=n;function s(u,l,f=new d){let m=Math.abs(u*Math.cos(l)),p=Math.abs(u*Math.sin(l));const y=e(f),x=k.normalize(k.toDeg(l));return x<90?p=-p:x<180?(m=-m,p=-p):x<270&&(m=-m),new d(y.x+m,y.y+p)}d.fromPolar=s;function i(u,l=new d){const f=e(u),m=e(l),p=f.x-m.x,y=f.y-m.y;return new d(Math.sqrt(p*p+y*y),k.toRad(m.theta(f)))}d.toPolar=i;function r(u,l){return u===l?!0:u!=null&&l!=null?u.x===l.x&&u.y===l.y:!1}d.equals=r;function o(u,l){if(u==null&&l!=null||u!=null&&l==null||u!=null&&l!=null&&u.length!==l.length)return!1;if(u!=null&&l!=null){for(let f=0,m=u.length;f<m;f+=1)if(!r(u[f],l[f]))return!1}return!0}d.equalPoints=o;function c(u,l,f,m){return new d(D.random(u,l),D.random(f,m))}d.random=c;function h(u,l,f){const m=k.toRad(k.normalize(-l)),p=Math.sin(m),y=Math.cos(m);return a(u,y,p,f)}d.rotate=h;function a(u,l,f,m=new d){const p=e(u),y=e(m),x=p.x-y.x,b=p.y-y.y,P=x*l-b*f,v=b*l+x*f;return new d(P+y.x,v+y.y)}d.rotateEx=a})(g||(g={}));class M extends F{get left(){return this.x}get top(){return this.y}get right(){return this.x+this.width}get bottom(){return this.y+this.height}get origin(){return new g(this.x,this.y)}get topLeft(){return new g(this.x,this.y)}get topCenter(){return new g(this.x+this.width/2,this.y)}get topRight(){return new g(this.x+this.width,this.y)}get center(){return new g(this.x+this.width/2,this.y+this.height/2)}get bottomLeft(){return new g(this.x,this.y+this.height)}get bottomCenter(){return new g(this.x+this.width/2,this.y+this.height)}get bottomRight(){return new g(this.x+this.width,this.y+this.height)}get corner(){return new g(this.x+this.width,this.y+this.height)}get rightMiddle(){return new g(this.x+this.width,this.y+this.height/2)}get leftMiddle(){return new g(this.x,this.y+this.height/2)}get topLine(){return new w(this.topLeft,this.topRight)}get rightLine(){return new w(this.topRight,this.bottomRight)}get bottomLine(){return new w(this.bottomLeft,this.bottomRight)}get leftLine(){return new w(this.topLeft,this.bottomLeft)}constructor(t,e,n,s){super(),this.x=t==null?0:t,this.y=e==null?0:e,this.width=n==null?0:n,this.height=s==null?0:s}getOrigin(){return this.origin}getTopLeft(){return this.topLeft}getTopCenter(){return this.topCenter}getTopRight(){return this.topRight}getCenter(){return this.center}getCenterX(){return this.x+this.width/2}getCenterY(){return this.y+this.height/2}getBottomLeft(){return this.bottomLeft}getBottomCenter(){return this.bottomCenter}getBottomRight(){return this.bottomRight}getCorner(){return this.corner}getRightMiddle(){return this.rightMiddle}getLeftMiddle(){return this.leftMiddle}getTopLine(){return this.topLine}getRightLine(){return this.rightLine}getBottomLine(){return this.bottomLine}getLeftLine(){return this.leftLine}bbox(t){if(!t)return this.clone();const e=k.toRad(t),n=Math.abs(Math.sin(e)),s=Math.abs(Math.cos(e)),i=this.width*s+this.height*n,r=this.width*n+this.height*s;return new M(this.x+(this.width-i)/2,this.y+(this.height-r)/2,i,r)}round(t=0){return this.x=D.round(this.x,t),this.y=D.round(this.y,t),this.width=D.round(this.width,t),this.height=D.round(this.height,t),this}add(t,e,n,s){const i=M.create(t,e,n,s),r=Math.min(this.x,i.x),o=Math.min(this.y,i.y),c=Math.max(this.x+this.width,i.x+i.width),h=Math.max(this.y+this.height,i.y+i.height);return this.x=r,this.y=o,this.width=c-r,this.height=h-o,this}update(t,e,n,s){const i=M.create(t,e,n,s);return this.x=i.x,this.y=i.y,this.width=i.width,this.height=i.height,this}inflate(t,e){const n=t,s=e!=null?e:t;return this.x-=n,this.y-=s,this.width+=2*n,this.height+=2*s,this}snapToGrid(t,e){const n=this.origin.snapToGrid(t,e),s=this.corner.snapToGrid(t,e);return this.x=n.x,this.y=n.y,this.width=s.x-n.x,this.height=s.y-n.y,this}translate(t,e){const n=g.create(t,e);return this.x+=n.x,this.y+=n.y,this}scale(t,e,n=new g){const s=this.origin.scale(t,e,n);return this.x=s.x,this.y=s.y,this.width*=t,this.height*=e,this}rotate(t,e=this.getCenter()){if(t!==0){const n=k.toRad(t),s=Math.cos(n),i=Math.sin(n);let r=this.getOrigin(),o=this.getTopRight(),c=this.getBottomRight(),h=this.getBottomLeft();r=g.rotateEx(r,s,i,e),o=g.rotateEx(o,s,i,e),c=g.rotateEx(c,s,i,e),h=g.rotateEx(h,s,i,e);const a=new M(r.x,r.y,0,0);a.add(o.x,o.y,0,0),a.add(c.x,c.y,0,0),a.add(h.x,h.y,0,0),this.update(a)}return this}rotate90(){const t=(this.width-this.height)/2;this.x+=t,this.y-=t;const e=this.width;return this.width=this.height,this.height=e,this}moveAndExpand(t){const e=M.clone(t);return this.x+=e.x||0,this.y+=e.y||0,this.width+=e.width||0,this.height+=e.height||0,this}getMaxScaleToFit(t,e=this.center){const n=M.clone(t),s=e.x,i=e.y;let r=1/0,o=1/0,c=1/0,h=1/0,a=1/0,u=1/0,l=1/0,f=1/0;const m=n.topLeft;m.x<s&&(r=(this.x-s)/(m.x-s)),m.y<i&&(a=(this.y-i)/(m.y-i));const p=n.bottomRight;p.x>s&&(o=(this.x+this.width-s)/(p.x-s)),p.y>i&&(u=(this.y+this.height-i)/(p.y-i));const y=n.topRight;y.x>s&&(c=(this.x+this.width-s)/(y.x-s)),y.y<i&&(l=(this.y-i)/(y.y-i));const x=n.bottomLeft;return x.x<s&&(h=(this.x-s)/(x.x-s)),x.y>i&&(f=(this.y+this.height-i)/(x.y-i)),{sx:Math.min(r,o,c,h),sy:Math.min(a,u,l,f)}}getMaxUniformScaleToFit(t,e=this.center){const n=this.getMaxScaleToFit(t,e);return Math.min(n.sx,n.sy)}containsPoint(t,e){return D.containsPoint(this,g.create(t,e))}containsRect(t,e,n,s){const i=M.create(t,e,n,s),r=this.x,o=this.y,c=this.width,h=this.height,a=i.x,u=i.y,l=i.width,f=i.height;return c===0||h===0||l===0||f===0?!1:a>=r&&u>=o&&a+l<=r+c&&u+f<=o+h}intersectsWithLine(t){const e=[this.topLine,this.rightLine,this.bottomLine,this.leftLine],n=[],s=[];return e.forEach(i=>{const r=t.intersectsWithLine(i);r!==null&&s.indexOf(r.toString())<0&&(n.push(r),s.push(r.toString()))}),n.length>0?n:null}intersectsWithLineFromCenterToPoint(t,e){const n=g.clone(t),s=this.center;let i=null;e!=null&&e!==0&&n.rotate(e,s);const r=[this.topLine,this.rightLine,this.bottomLine,this.leftLine],o=new w(s,n);for(let c=r.length-1;c>=0;c-=1){const h=r[c].intersectsWithLine(o);if(h!==null){i=h;break}}return i&&e!=null&&e!==0&&i.rotate(-e,s),i}intersectsWithRect(t,e,n,s){const i=M.create(t,e,n,s);if(!this.isIntersectWithRect(i))return null;const r=this.origin,o=this.corner,c=i.origin,h=i.corner,a=Math.max(r.x,c.x),u=Math.max(r.y,c.y);return new M(a,u,Math.min(o.x,h.x)-a,Math.min(o.y,h.y)-u)}isIntersectWithRect(t,e,n,s){const i=M.create(t,e,n,s),r=this.origin,o=this.corner,c=i.origin,h=i.corner;return!(h.x<=r.x||h.y<=r.y||c.x>=o.x||c.y>=o.y)}normalize(){let t=this.x,e=this.y,n=this.width,s=this.height;return this.width<0&&(t=this.x+this.width,n=-this.width),this.height<0&&(e=this.y+this.height,s=-this.height),this.x=t,this.y=e,this.width=n,this.height=s,this}union(t){const e=M.clone(t),n=this.origin,s=this.corner,i=e.origin,r=e.corner,o=Math.min(n.x,i.x),c=Math.min(n.y,i.y),h=Math.max(s.x,r.x),a=Math.max(s.y,r.y);return new M(o,c,h-o,a-c)}getNearestSideToPoint(t){const e=g.clone(t),n=e.x-this.x,s=this.x+this.width-e.x,i=e.y-this.y,r=this.y+this.height-e.y;let o=n,c="left";return s<o&&(o=s,c="right"),i<o&&(o=i,c="top"),r<o&&(c="bottom"),c}getNearestPointToPoint(t){const e=g.clone(t);if(this.containsPoint(e)){const n=this.getNearestSideToPoint(e);if(n==="left")return new g(this.x,e.y);if(n==="top")return new g(e.x,this.y);if(n==="right")return new g(this.x+this.width,e.y);if(n==="bottom")return new g(e.x,this.y+this.height)}return e.adhereToRect(this)}equals(t){return t!=null&&t.x===this.x&&t.y===this.y&&t.width===this.width&&t.height===this.height}clone(){return new M(this.x,this.y,this.width,this.height)}toJSON(){return{x:this.x,y:this.y,width:this.width,height:this.height}}serialize(){return`${this.x} ${this.y} ${this.width} ${this.height}`}}(function(d){function t(e){return e!=null&&e instanceof d}d.isRectangle=t})(M||(M={}));(function(d){function t(e){return e!=null&&typeof e=="object"&&typeof e.x=="number"&&typeof e.y=="number"&&typeof e.width=="number"&&typeof e.height=="number"}d.isRectangleLike=t})(M||(M={}));(function(d){function t(r,o,c,h){return r==null||typeof r=="number"?new d(r,o,c,h):e(r)}d.create=t;function e(r){return d.isRectangle(r)?r.clone():Array.isArray(r)?new d(r[0],r[1],r[2],r[3]):new d(r.x,r.y,r.width,r.height)}d.clone=e;function n(r){return new d(r.x-r.a,r.y-r.b,2*r.a,2*r.b)}d.fromEllipse=n;function s(r){return new d(0,0,r.width,r.height)}d.fromSize=s;function i(r,o){return new d(r.x,r.y,o.width,o.height)}d.fromPositionAndSize=i})(M||(M={}));class w extends F{get center(){return new g((this.start.x+this.end.x)/2,(this.start.y+this.end.y)/2)}constructor(t,e,n,s){super(),typeof t=="number"&&typeof e=="number"?(this.start=new g(t,e),this.end=new g(n,s)):(this.start=g.create(t),this.end=g.create(e))}getCenter(){return this.center}round(t=0){return this.start.round(t),this.end.round(t),this}translate(t,e){return typeof t=="number"?(this.start.translate(t,e),this.end.translate(t,e)):(this.start.translate(t),this.end.translate(t)),this}rotate(t,e){return this.start.rotate(t,e),this.end.rotate(t,e),this}scale(t,e,n){return this.start.scale(t,e,n),this.end.scale(t,e,n),this}length(){return Math.sqrt(this.squaredLength())}squaredLength(){const t=this.start.x-this.end.x,e=this.start.y-this.end.y;return t*t+e*e}setLength(t){const e=this.length();if(!e)return this;const n=t/e;return this.scale(n,n,this.start)}parallel(t){const e=this.clone();if(!e.isDifferentiable())return e;const{start:n,end:s}=e,i=n.clone().rotate(270,s),r=s.clone().rotate(90,n);return n.move(r,t),s.move(i,t),e}vector(){return new g(this.end.x-this.start.x,this.end.y-this.start.y)}angle(){const t=new g(this.start.x+1,this.start.y);return this.start.angleBetween(this.end,t)}bbox(){const t=Math.min(this.start.x,this.end.x),e=Math.min(this.start.y,this.end.y),n=Math.max(this.start.x,this.end.x),s=Math.max(this.start.y,this.end.y);return new M(t,e,n-t,s-e)}bearing(){return this.start.bearing(this.end)}closestPoint(t){return this.pointAt(this.closestPointNormalizedLength(t))}closestPointLength(t){return this.closestPointNormalizedLength(t)*this.length()}closestPointTangent(t){return this.tangentAt(this.closestPointNormalizedLength(t))}closestPointNormalizedLength(t){const e=this.vector().dot(new w(this.start,t).vector()),n=Math.min(1,Math.max(0,e/this.squaredLength()));return Number.isNaN(n)?0:n}pointAt(t){const e=this.start,n=this.end;return t<=0?e.clone():t>=1?n.clone():e.lerp(n,t)}pointAtLength(t){const e=this.start,n=this.end;let s=!0;t<0&&(s=!1,t=-t);const i=this.length();if(t>=i)return s?n.clone():e.clone();const r=(s?t:i-t)/i;return this.pointAt(r)}divideAt(t){const e=this.pointAt(t);return[new w(this.start,e),new w(e,this.end)]}divideAtLength(t){const e=this.pointAtLength(t);return[new w(this.start,e),new w(e,this.end)]}containsPoint(t){const e=this.start,n=this.end;if(e.cross(t,n)!==0)return!1;const s=this.length();return!(new w(e,t).length()>s||new w(t,n).length()>s)}intersect(t,e){const n=t.intersectsWithLine(this,e);return n?Array.isArray(n)?n:[n]:null}intersectsWithLine(t){const e=new g(this.end.x-this.start.x,this.end.y-this.start.y),n=new g(t.end.x-t.start.x,t.end.y-t.start.y),s=e.x*n.y-e.y*n.x,i=new g(t.start.x-this.start.x,t.start.y-this.start.y),r=i.x*n.y-i.y*n.x,o=i.x*e.y-i.y*e.x;if(s===0||r*s<0||o*s<0)return null;if(s>0){if(r>s||o>s)return null}else if(r<s||o<s)return null;return new g(this.start.x+r*e.x/s,this.start.y+r*e.y/s)}isDifferentiable(){return!this.start.equals(this.end)}pointOffset(t){const e=g.clone(t),n=this.start,s=this.end;return((s.x-n.x)*(e.y-n.y)-(s.y-n.y)*(e.x-n.x))/this.length()}pointSquaredDistance(t,e){const n=g.create(t,e);return this.closestPoint(n).squaredDistance(n)}pointDistance(t,e){const n=g.create(t,e);return this.closestPoint(n).distance(n)}tangentAt(t){if(!this.isDifferentiable())return null;const e=this.start,n=this.end,s=this.pointAt(t),i=new w(e,n);return i.translate(s.x-e.x,s.y-e.y),i}tangentAtLength(t){if(!this.isDifferentiable())return null;const e=this.start,n=this.end,s=this.pointAtLength(t),i=new w(e,n);return i.translate(s.x-e.x,s.y-e.y),i}relativeCcw(t,e){const n=g.create(t,e);let s=n.x-this.start.x,i=n.y-this.start.y;const r=this.end.x-this.start.x,o=this.end.y-this.start.y;let c=s*o-i*r;return c===0&&(c=s*r+i*o,c>0&&(s-=r,i-=o,c=s*r+i*o,c<0&&(c=0))),c<0?-1:c>0?1:0}equals(t){return t!=null&&this.start.x===t.start.x&&this.start.y===t.start.y&&this.end.x===t.end.x&&this.end.y===t.end.y}clone(){return new w(this.start,this.end)}toJSON(){return{start:this.start.toJSON(),end:this.end.toJSON()}}serialize(){return[this.start.serialize(),this.end.serialize()].join(" ")}}(function(d){function t(e){return e!=null&&e instanceof d}d.isLine=t})(w||(w={}));class B extends F{get center(){return new g(this.x,this.y)}constructor(t,e,n,s){super(),this.x=t==null?0:t,this.y=e==null?0:e,this.a=n==null?0:n,this.b=s==null?0:s}bbox(){return M.fromEllipse(this)}getCenter(){return this.center}inflate(t,e){const n=t,s=e!=null?e:t;return this.a+=2*n,this.b+=2*s,this}normalizedDistance(t,e){const n=g.create(t,e),s=n.x-this.x,i=n.y-this.y,r=this.a,o=this.b;return s*s/(r*r)+i*i/(o*o)}containsPoint(t,e){return this.normalizedDistance(t,e)<=1}intersectsWithLine(t){const e=[],n=this.a,s=this.b,i=t.start,r=t.end,o=t.vector(),c=i.diff(new g(this.x,this.y)),h=new g(o.x/(n*n),o.y/(s*s)),a=new g(c.x/(n*n),c.y/(s*s)),u=o.dot(h),l=o.dot(a),f=c.dot(a)-1,m=l*l-u*f;if(m<0)return null;if(m>0){const p=Math.sqrt(m),y=(-l-p)/u,x=(-l+p)/u;if((y<0||y>1)&&(x<0||x>1))return null;y>=0&&y<=1&&e.push(i.lerp(r,y)),x>=0&&x<=1&&e.push(i.lerp(r,x))}else{const p=-l/u;if(p>=0&&p<=1)e.push(i.lerp(r,p));else return null}return e}intersectsWithLineFromCenterToPoint(t,e=0){const n=g.clone(t);e&&n.rotate(e,this.getCenter());const s=n.x-this.x,i=n.y-this.y;let r;if(s===0)return r=this.bbox().getNearestPointToPoint(n),e?r.rotate(-e,this.getCenter()):r;const o=i/s,c=o*o,h=this.a*this.a,a=this.b*this.b;let u=Math.sqrt(1/(1/h+c/a));u=s<0?-u:u;const l=o*u;return r=new g(this.x+u,this.y+l),e?r.rotate(-e,this.getCenter()):r}tangentTheta(t){const e=g.clone(t),n=e.x,s=e.y,i=this.a,r=this.b,o=this.bbox().center,c=o.x,h=o.y,a=30,u=n>o.x+i/2,l=n<o.x-i/2;let f,m;return u||l?(m=n>o.x?s-a:s+a,f=i*i/(n-c)-i*i*(s-h)*(m-h)/(r*r*(n-c))+c):(f=s>o.y?n+a:n-a,m=r*r/(s-h)-r*r*(n-c)*(f-c)/(i*i*(s-h))+h),new g(f,m).theta(e)}scale(t,e){return this.a*=t,this.b*=e,this}rotate(t,e){const n=M.fromEllipse(this);n.rotate(t,e);const s=B.fromRect(n);return this.a=s.a,this.b=s.b,this.x=s.x,this.y=s.y,this}translate(t,e){const n=g.create(t,e);return this.x+=n.x,this.y+=n.y,this}equals(t){return t!=null&&t.x===this.x&&t.y===this.y&&t.a===this.a&&t.b===this.b}clone(){return new B(this.x,this.y,this.a,this.b)}toJSON(){return{x:this.x,y:this.y,a:this.a,b:this.b}}serialize(){return`${this.x} ${this.y} ${this.a} ${this.b}`}}(function(d){function t(e){return e!=null&&e instanceof d}d.isEllipse=t})(B||(B={}));(function(d){function t(s,i,r,o){return s==null||typeof s=="number"?new d(s,i,r,o):e(s)}d.create=t;function e(s){return d.isEllipse(s)?s.clone():Array.isArray(s)?new d(s[0],s[1],s[2],s[3]):new d(s.x,s.y,s.a,s.b)}d.parse=e;function n(s){const i=s.center;return new d(i.x,i.y,s.width/2,s.height/2)}d.fromRect=n})(B||(B={}));const pt=new RegExp("^[\\s\\dLMCZz,.]*$");function yt(d){return typeof d!="string"?!1:pt.test(d)}function ot(d,t){return(d%t+t)%t}function xt(d,t,e,n,s){const i=[],r=d[d.length-1],o=t!=null&&t>0,c=t||0;if(n&&o){d=d.slice();const u=d[0],l=new g(r.x+(u.x-r.x)/2,r.y+(u.y-r.y)/2);d.splice(0,0,l)}let h=d[0],a=1;for(e?i.push("M",h.x,h.y):i.push("L",h.x,h.y);a<(n?d.length:d.length-1);){let u=d[ot(a,d.length)],l=h.x-u.x,f=h.y-u.y;if(o&&(l!==0||f!==0)&&(s==null||s.indexOf(a-1)<0)){let m=Math.sqrt(l*l+f*f);const p=l*Math.min(c,m/2)/m,y=f*Math.min(c,m/2)/m,x=u.x+p,b=u.y+y;i.push("L",x,b);let P=d[ot(a+1,d.length)];for(;a<d.length-2&&Math.round(P.x-u.x)===0&&Math.round(P.y-u.y)===0;)P=d[ot(a+2,d.length)],a+=1;l=P.x-u.x,f=P.y-u.y,m=Math.max(1,Math.sqrt(l*l+f*f));const v=l*Math.min(c,m/2)/m,S=f*Math.min(c,m/2)/m,N=u.x+v,C=u.y+S;i.push("Q",u.x,u.y,N,C),u=new g(N,C)}else i.push("L",u.x,u.y);h=u,a+=1}return n?i.push("Z"):i.push("L",r.x,r.y),i.map(u=>typeof u=="string"?u:+u.toFixed(3)).join(" ")}function dt(d,t={}){const e=[];return d&&d.length&&d.forEach(n=>{Array.isArray(n)?e.push({x:n[0],y:n[1]}):e.push({x:n.x,y:n.y})}),xt(e,t.round,t.initialMove==null||t.initialMove,t.close,t.exclude)}function rt(d,t,e,n,s=0,i=0,r=0,o,c){if(e===0||n===0)return[];o-=d,c-=t,e=Math.abs(e),n=Math.abs(n);const h=-o/2,a=-c/2,u=Math.cos(s*Math.PI/180),l=Math.sin(s*Math.PI/180),f=u*h+l*a,m=-1*l*h+u*a,p=f*f,y=m*m,x=e*e,b=n*n,P=p/x+y/b;let v;if(P>1)e=Math.sqrt(P)*e,n=Math.sqrt(P)*n,v=0;else{let H=1;i===r&&(H=-1),v=H*Math.sqrt((x*b-x*y-b*p)/(x*y+b*p))}const S=v*e*m/n,N=-1*v*n*f/e,C=u*S-l*N+o/2,R=l*S+u*N+c/2;let A=Math.atan2((m-N)/n,(f-S)/e)-Math.atan2(0,1),O=A>=0?A:2*Math.PI+A;A=Math.atan2((-m-N)/n,(-f-S)/e)-Math.atan2((m-N)/n,(f-S)/e);let L=A>=0?A:2*Math.PI+A;r===0&&L>0?L-=2*Math.PI:r!==0&&L<0&&(L+=2*Math.PI);const V=L*2/Math.PI,W=Math.ceil(V<0?-1*V:V),z=L/W,E=8/3*Math.sin(z/4)*Math.sin(z/4)/Math.sin(z/2),T=u*e,Z=u*n,Y=l*e,K=l*n;let G=Math.cos(O),Q=Math.sin(O),ht=-E*(T*Q+K*G),ct=-E*(Y*Q-Z*G),nt=0,st=0;const X=[];for(let H=0;H<W;H+=1){O+=z,G=Math.cos(O),Q=Math.sin(O),nt=T*G-K*Q+C,st=Y*G+Z*Q+R;const lt=-E*(T*Q+K*G),ut=-E*(Y*Q-Z*G),U=H*6;X[U]=Number(ht+d),X[U+1]=Number(ct+t),X[U+2]=Number(nt-lt+d),X[U+3]=Number(st-ut+t),X[U+4]=Number(nt+d),X[U+5]=Number(st+t),ht=nt+lt,ct=st+ut}return X.map(H=>+H.toFixed(2))}function bt(d,t,e,n,s=0,i=0,r=0,o,c){const h=[],a=rt(d,t,e,n,s,i,r,o,c);if(a!=null)for(let u=0,l=a.length;u<l;u+=6)h.push("C",a[u],a[u+1],a[u+2],a[u+3],a[u+4],a[u+5]);return h.join(" ")}class $ extends F{get start(){return this.points[0]||null}get end(){return this.points[this.points.length-1]||null}constructor(t){if(super(),t!=null){if(typeof t=="string")return $.parse(t);this.points=t.map(e=>g.create(e))}else this.points=[]}scale(t,e,n=new g){return this.points.forEach(s=>s.scale(t,e,n)),this}rotate(t,e){return this.points.forEach(n=>n.rotate(t,e)),this}translate(t,e){const n=g.create(t,e);return this.points.forEach(s=>s.translate(n.x,n.y)),this}round(t=0){return this.points.forEach(e=>e.round(t)),this}bbox(){if(this.points.length===0)return new M;let t=1/0,e=-1/0,n=1/0,s=-1/0;const i=this.points;for(let r=0,o=i.length;r<o;r+=1){const c=i[r],h=c.x,a=c.y;h<t&&(t=h),h>e&&(e=h),a<n&&(n=a),a>s&&(s=a)}return new M(t,n,e-t,s-n)}closestPoint(t){const e=this.closestPointLength(t);return this.pointAtLength(e)}closestPointLength(t){const e=this.points,n=e.length;if(n===0||n===1)return 0;let s=0,i=0,r=1/0;for(let o=0,c=n-1;o<c;o+=1){const h=new w(e[o],e[o+1]),a=h.length(),u=h.closestPointNormalizedLength(t),f=h.pointAt(u).squaredDistance(t);f<r&&(r=f,i=s+u*a),s+=a}return i}closestPointNormalizedLength(t){const e=this.length();return e===0?0:this.closestPointLength(t)/e}closestPointTangent(t){const e=this.closestPointLength(t);return this.tangentAtLength(e)}containsPoint(t){if(this.points.length===0)return!1;const e=g.clone(t),n=e.x,s=e.y,i=this.points,r=i.length;let o=r-1,c=0;for(let h=0;h<r;h+=1){const a=i[o],u=i[h];if(e.equals(a))return!0;const l=new w(a,u);if(l.containsPoint(t))return!0;if(s<=a.y&&s>u.y||s>a.y&&s<=u.y){const f=a.x-n>u.x-n?a.x-n:u.x-n;if(f>=0){const m=new g(n+f,s),p=new w(t,m);l.intersectsWithLine(p)&&(c+=1)}}o=h}return c%2===1}intersectsWithLine(t){const e=[];for(let n=0,s=this.points.length-1;n<s;n+=1){const i=this.points[n],r=this.points[n+1],o=t.intersectsWithLine(new w(i,r));o&&e.push(o)}return e.length>0?e:null}isDifferentiable(){for(let t=0,e=this.points.length-1;t<e;t+=1){const n=this.points[t],s=this.points[t+1];if(new w(n,s).isDifferentiable())return!0}return!1}length(){let t=0;for(let e=0,n=this.points.length-1;e<n;e+=1){const s=this.points[e],i=this.points[e+1];t+=s.distance(i)}return t}pointAt(t){const e=this.points,n=e.length;if(n===0)return null;if(n===1||t<=0)return e[0].clone();if(t>=1)return e[n-1].clone();const i=this.length()*t;return this.pointAtLength(i)}pointAtLength(t){const e=this.points,n=e.length;if(n===0)return null;if(n===1)return e[0].clone();let s=!0;t<0&&(s=!1,t=-t);let i=0;for(let o=0,c=n-1;o<c;o+=1){const h=s?o:c-1-o,a=e[h],u=e[h+1],l=new w(a,u),f=a.distance(u);if(t<=i+f)return l.pointAtLength((s?1:-1)*(t-i));i+=f}return(s?e[n-1]:e[0]).clone()}tangentAt(t){const n=this.points.length;if(n===0||n===1)return null;t<0&&(t=0),t>1&&(t=1);const i=this.length()*t;return this.tangentAtLength(i)}tangentAtLength(t){const e=this.points,n=e.length;if(n===0||n===1)return null;let s=!0;t<0&&(s=!1,t=-t);let i,r=0;for(let o=0,c=n-1;o<c;o+=1){const h=s?o:c-1-o,a=e[h],u=e[h+1],l=new w(a,u),f=a.distance(u);if(l.isDifferentiable()){if(t<=r+f)return l.tangentAtLength((s?1:-1)*(t-r));i=l}r+=f}if(i){const o=s?1:0;return i.tangentAt(o)}return null}simplify(t={}){const e=this.points;if(e.length<3)return this;const n=t.threshold||0;let s=0;for(;e[s+2];){const i=s,r=s+1,o=s+2,c=e[i],h=e[r],a=e[o];new w(c,a).closestPoint(h).distance(h)<=n?e.splice(r,1):s+=1}return this}toHull(){const t=this.points,e=t.length;if(e===0)return new $;let n=t[0];for(let l=1;l<e;l+=1)(t[l].y<n.y||t[l].y===n.y&&t[l].x>n.x)&&(n=t[l]);const s=[];for(let l=0;l<e;l+=1){let f=n.theta(t[l]);f===0&&(f=360),s.push([t[l],l,f])}if(s.sort((l,f)=>{let m=l[2]-f[2];return m===0&&(m=f[1]-l[1]),m}),s.length>2){const l=s[s.length-1];s.unshift(l)}const i={},r=[],o=l=>`${l[0].toString()}@${l[1]}`;for(;s.length!==0;){const l=s.pop(),f=l[0];if(i[o(l)])continue;let m=!1;for(;!m;)if(r.length<2)r.push(l),m=!0;else{const p=r.pop(),y=p[0],x=r.pop(),b=x[0],P=b.cross(y,f);if(P<0)r.push(x),r.push(p),r.push(l),m=!0;else if(P===0){const S=y.angleBetween(b,f);Math.abs(S-180)<1e-10||y.equals(f)||b.equals(y)?(i[o(p)]=y,r.push(x)):Math.abs((S+1)%360-1)<1e-10&&(r.push(x),s.push(p))}else i[o(p)]=y,r.push(x)}}r.length>2&&r.pop();let c,h=-1;for(let l=0,f=r.length;l<f;l+=1){const m=r[l][1];(c===void 0||m<c)&&(c=m,h=l)}let a=[];if(h>0){const l=r.slice(h),f=r.slice(0,h);a=l.concat(f)}else a=r;const u=[];for(let l=0,f=a.length;l<f;l+=1)u.push(a[l][0]);return new $(u)}equals(t){return t==null||t.points.length!==this.points.length?!1:t.points.every((e,n)=>e.equals(this.points[n]))}clone(){return new $(this.points.map(t=>t.clone()))}toJSON(){return this.points.map(t=>t.toJSON())}serialize(){return this.points.map(t=>`${t.serialize()}`).join(" ")}}(function(d){function t(e){return e!=null&&e instanceof d}d.isPolyline=t})($||($={}));(function(d){function t(e){const n=e.trim();if(n==="")return new d;const s=[],i=n.split(/\s*,\s*|\s+/);for(let r=0,o=i.length;r<o;r+=2)s.push({x:+i[r],y:+i[r+1]});return new d(s)}d.parse=t})($||($={}));class I extends F{constructor(t,e,n,s){super(),this.PRECISION=3,this.start=g.create(t),this.controlPoint1=g.create(e),this.controlPoint2=g.create(n),this.end=g.create(s)}bbox(){const t=this.start,e=this.controlPoint1,n=this.controlPoint2,s=this.end,i=t.x,r=t.y,o=e.x,c=e.y,h=n.x,a=n.y,u=s.x,l=s.y,f=[],m=[[],[]];let p,y,x,b,P,v,S,N;for(let T=0;T<2;T+=1){if(T===0?(y=6*i-12*o+6*h,p=-3*i+9*o-9*h+3*u,x=3*o-3*i):(y=6*r-12*c+6*a,p=-3*r+9*c-9*a+3*l,x=3*c-3*r),Math.abs(p)<1e-12){if(Math.abs(y)<1e-12)continue;b=-x/y,b>0&&b<1&&f.push(b);continue}S=y*y-4*x*p,N=Math.sqrt(S),!(S<0)&&(P=(-y+N)/(2*p),P>0&&P<1&&f.push(P),v=(-y-N)/(2*p),v>0&&v<1&&f.push(v))}let C,R,A,O=f.length;const L=O;for(;O;)O-=1,b=f[O],A=1-b,C=A*A*A*i+3*A*A*b*o+3*A*b*b*h+b*b*b*u,m[0][O]=C,R=A*A*A*r+3*A*A*b*c+3*A*b*b*a+b*b*b*l,m[1][O]=R;f[L]=0,f[L+1]=1,m[0][L]=i,m[1][L]=r,m[0][L+1]=u,m[1][L+1]=l,f.length=L+2,m[0].length=L+2,m[1].length=L+2;const V=Math.min.apply(null,m[0]),W=Math.min.apply(null,m[1]),z=Math.max.apply(null,m[0]),E=Math.max.apply(null,m[1]);return new M(V,W,z-V,E-W)}closestPoint(t,e={}){return this.pointAtT(this.closestPointT(t,e))}closestPointLength(t,e={}){const n=this.getOptions(e);return this.lengthAtT(this.closestPointT(t,n),n)}closestPointNormalizedLength(t,e={}){const n=this.getOptions(e),s=this.closestPointLength(t,n);if(!s)return 0;const i=this.length(n);return i===0?0:s/i}closestPointT(t,e={}){const n=this.getPrecision(e),s=this.getDivisions(e),i=Math.pow(10,-n);let r=null,o=0,c=0,h=0,a=0,u=0,l=null;const f=s.length;let m=f>0?1/f:0;for(s.forEach((p,y)=>{const x=p.start.distance(t),b=p.end.distance(t),P=x+b;(l==null||P<l)&&(r=p,o=y*m,c=(y+1)*m,h=x,a=b,l=P,u=p.endpointDistance())});;){const p=h?Math.abs(h-a)/h:0,y=a!=null?Math.abs(h-a)/a:0,x=p<i||y<i,b=h?h<u*i:!0,P=a?a<u*i:!0;if(x||(b||P))return h<=a?o:c;const S=r.divide(.5);m/=2;const N=S[0].start.distance(t),C=S[0].end.distance(t),R=N+C,A=S[1].start.distance(t),O=S[1].end.distance(t),L=A+O;R<=L?(r=S[0],c-=m,h=N,a=C):(r=S[1],o+=m,h=A,a=O)}}closestPointTangent(t,e={}){return this.tangentAtT(this.closestPointT(t,e))}containsPoint(t,e={}){return this.toPolyline(e).containsPoint(t)}divideAt(t,e={}){if(t<=0)return this.divideAtT(0);if(t>=1)return this.divideAtT(1);const n=this.tAt(t,e);return this.divideAtT(n)}divideAtLength(t,e={}){const n=this.tAtLength(t,e);return this.divideAtT(n)}divide(t){return this.divideAtT(t)}divideAtT(t){const e=this.start,n=this.controlPoint1,s=this.controlPoint2,i=this.end;if(t<=0)return[new I(e,e,e,e),new I(e,n,s,i)];if(t>=1)return[new I(e,n,s,i),new I(i,i,i,i)];const r=this.getSkeletonPoints(t),o=r.startControlPoint1,c=r.startControlPoint2,h=r.divider,a=r.dividerControlPoint1,u=r.dividerControlPoint2;return[new I(e,o,c,h),new I(h,a,u,i)]}endpointDistance(){return this.start.distance(this.end)}getSkeletonPoints(t){const e=this.start,n=this.controlPoint1,s=this.controlPoint2,i=this.end;if(t<=0)return{startControlPoint1:e.clone(),startControlPoint2:e.clone(),divider:e.clone(),dividerControlPoint1:n.clone(),dividerControlPoint2:s.clone()};if(t>=1)return{startControlPoint1:n.clone(),startControlPoint2:s.clone(),divider:i.clone(),dividerControlPoint1:i.clone(),dividerControlPoint2:i.clone()};const r=new w(e,n).pointAt(t),o=new w(n,s).pointAt(t),c=new w(s,i).pointAt(t),h=new w(r,o).pointAt(t),a=new w(o,c).pointAt(t),u=new w(h,a).pointAt(t);return{startControlPoint1:r,startControlPoint2:h,divider:u,dividerControlPoint1:a,dividerControlPoint2:c}}getSubdivisions(t={}){const e=this.getPrecision(t);let n=[new I(this.start,this.controlPoint1,this.controlPoint2,this.end)];if(e===0)return n;let s=this.endpointDistance();const i=Math.pow(10,-e);let r=0;for(;;){r+=1;const o=[];n.forEach(a=>{const u=a.divide(.5);o.push(u[0],u[1])});const c=o.reduce((a,u)=>a+u.endpointDistance(),0),h=c!==0?(c-s)/c:0;if(r>1&&h<i)return o;n=o,s=c}}length(t={}){return this.getDivisions(t).reduce((n,s)=>n+s.endpointDistance(),0)}lengthAtT(t,e={}){if(t<=0)return 0;const n=e.precision===void 0?this.PRECISION:e.precision;return this.divide(t)[0].length({precision:n})}pointAt(t,e={}){if(t<=0)return this.start.clone();if(t>=1)return this.end.clone();const n=this.tAt(t,e);return this.pointAtT(n)}pointAtLength(t,e={}){const n=this.tAtLength(t,e);return this.pointAtT(n)}pointAtT(t){return t<=0?this.start.clone():t>=1?this.end.clone():this.getSkeletonPoints(t).divider}isDifferentiable(){const t=this.start,e=this.controlPoint1,n=this.controlPoint2,s=this.end;return!(t.equals(e)&&e.equals(n)&&n.equals(s))}tangentAt(t,e={}){if(!this.isDifferentiable())return null;t<0?t=0:t>1&&(t=1);const n=this.tAt(t,e);return this.tangentAtT(n)}tangentAtLength(t,e={}){if(!this.isDifferentiable())return null;const n=this.tAtLength(t,e);return this.tangentAtT(n)}tangentAtT(t){if(!this.isDifferentiable())return null;t<0&&(t=0),t>1&&(t=1);const e=this.getSkeletonPoints(t),n=e.startControlPoint2,s=e.dividerControlPoint1,i=e.divider,r=new w(n,s);return r.translate(i.x-n.x,i.y-n.y),r}getPrecision(t={}){return t.precision==null?this.PRECISION:t.precision}getDivisions(t={}){if(t.subdivisions!=null)return t.subdivisions;const e=this.getPrecision(t);return this.getSubdivisions({precision:e})}getOptions(t={}){const e=this.getPrecision(t),n=this.getDivisions(t);return{precision:e,subdivisions:n}}tAt(t,e={}){if(t<=0)return 0;if(t>=1)return 1;const n=this.getOptions(e),i=this.length(n)*t;return this.tAtLength(i,n)}tAtLength(t,e={}){let n=!0;t<0&&(n=!1,t=-t);const s=this.getPrecision(e),i=this.getDivisions(e),r={precision:s,subdivisions:i};let o=null,c,h,a=0,u=0,l=0;const f=i.length;let m=f>0?1/f:0;for(let x=0;x<f;x+=1){const b=n?x:f-1-x,P=i[x],v=P.endpointDistance();if(t<=l+v){o=P,c=b*m,h=(b+1)*m,a=n?t-l:v+l-t,u=n?v+l-t:t-l;break}l+=v}if(o==null)return n?1:0;const p=this.length(r),y=Math.pow(10,-s);for(;;){let x;if(x=p!==0?a/p:0,x<y)return c;if(x=p!==0?u/p:0,x<y)return h;let b,P;const v=o.divide(.5);m/=2;const S=v[0].endpointDistance(),N=v[1].endpointDistance();a<=S?(o=v[0],h-=m,b=a,P=S-b):(o=v[1],c+=m,b=a-S,P=N-b),a=b,u=P}}toPoints(t={}){const e=this.getDivisions(t),n=[e[0].start.clone()];return e.forEach(s=>n.push(s.end.clone())),n}toPolyline(t={}){return new $(this.toPoints(t))}scale(t,e,n){return this.start.scale(t,e,n),this.controlPoint1.scale(t,e,n),this.controlPoint2.scale(t,e,n),this.end.scale(t,e,n),this}rotate(t,e){return this.start.rotate(t,e),this.controlPoint1.rotate(t,e),this.controlPoint2.rotate(t,e),this.end.rotate(t,e),this}translate(t,e){return typeof t=="number"?(this.start.translate(t,e),this.controlPoint1.translate(t,e),this.controlPoint2.translate(t,e),this.end.translate(t,e)):(this.start.translate(t),this.controlPoint1.translate(t),this.controlPoint2.translate(t),this.end.translate(t)),this}equals(t){return t!=null&&this.start.equals(t.start)&&this.controlPoint1.equals(t.controlPoint1)&&this.controlPoint2.equals(t.controlPoint2)&&this.end.equals(t.end)}clone(){return new I(this.start,this.controlPoint1,this.controlPoint2,this.end)}toJSON(){return{start:this.start.toJSON(),controlPoint1:this.controlPoint1.toJSON(),controlPoint2:this.controlPoint2.toJSON(),end:this.end.toJSON()}}serialize(){return[this.start.serialize(),this.controlPoint1.serialize(),this.controlPoint2.serialize(),this.end.serialize()].join(" ")}}(function(d){function t(e){return e!=null&&e instanceof d}d.isCurve=t})(I||(I={}));(function(d){function t(s){const i=s.length,r=[],o=[];let c=2;r[0]=s[0]/c;for(let h=1;h<i;h+=1)o[h]=1/c,c=(h<i-1?4:3.5)-o[h],r[h]=(s[h]-r[h-1])/c;for(let h=1;h<i;h+=1)r[i-h-1]-=o[i-h]*r[i-h];return r}function e(s){const i=s.map(l=>g.clone(l)),r=[],o=[],c=i.length-1;if(c===1)return r[0]=new g((2*i[0].x+i[1].x)/3,(2*i[0].y+i[1].y)/3),o[0]=new g(2*r[0].x-i[0].x,2*r[0].y-i[0].y),[r,o];const h=[];for(let l=1;l<c-1;l+=1)h[l]=4*i[l].x+2*i[l+1].x;h[0]=i[0].x+2*i[1].x,h[c-1]=(8*i[c-1].x+i[c].x)/2;const a=t(h);for(let l=1;l<c-1;l+=1)h[l]=4*i[l].y+2*i[l+1].y;h[0]=i[0].y+2*i[1].y,h[c-1]=(8*i[c-1].y+i[c].y)/2;const u=t(h);for(let l=0;l<c;l+=1)r.push(new g(a[l],u[l])),l<c-1?o.push(new g(2*i[l+1].x-a[l+1],2*i[l+1].y-u[l+1])):o.push(new g((i[c].x+a[c-1])/2,(i[c].y+u[c-1])/2));return[r,o]}function n(s){if(s==null||Array.isArray(s)&&s.length<2)throw new Error("At least 2 points are required");const i=e(s),r=[];for(let o=0,c=i[0].length;o<c;o+=1){const h=new g(i[0][o].x,i[0][o].y),a=new g(i[1][o].x,i[1][o].y);r.push(new d(s[o],h,a,s[o+1]))}return r}d.throughPoints=n})(I||(I={}));class et extends F{constructor(){super(...arguments),this.isVisible=!0,this.isSegment=!0,this.isSubpathStart=!1}get end(){return this.endPoint}get start(){if(this.previousSegment==null)throw new Error("Missing previous segment. (This segment cannot be the first segment of a path, or segment has not yet been added to a path.)");return this.previousSegment.end}closestPointT(t,e){if(this.closestPointNormalizedLength)return this.closestPointNormalizedLength(t);throw new Error("Neither `closestPointT` nor `closestPointNormalizedLength` method is implemented.")}lengthAtT(t,e){if(t<=0)return 0;const n=this.length();return t>=1?n:n*t}divideAtT(t){if(this.divideAt)return this.divideAt(t);throw new Error("Neither `divideAtT` nor `divideAt` method is implemented.")}pointAtT(t){if(this.pointAt)return this.pointAt(t);throw new Error("Neither `pointAtT` nor `pointAt` method is implemented.")}tangentAtT(t){if(this.tangentAt)return this.tangentAt(t);throw new Error("Neither `tangentAtT` nor `tangentAt` method is implemented.")}}class J extends et{constructor(t,e){super(),w.isLine(t)?this.endPoint=t.end.clone().round(2):this.endPoint=g.create(t,e).round(2)}get type(){return"L"}get line(){return new w(this.start,this.end)}bbox(){return this.line.bbox()}closestPoint(t){return this.line.closestPoint(t)}closestPointLength(t){return this.line.closestPointLength(t)}closestPointNormalizedLength(t){return this.line.closestPointNormalizedLength(t)}closestPointTangent(t){return this.line.closestPointTangent(t)}length(){return this.line.length()}divideAt(t){const e=this.line.divideAt(t);return[new J(e[0]),new J(e[1])]}divideAtLength(t){const e=this.line.divideAtLength(t);return[new J(e[0]),new J(e[1])]}getSubdivisions(){return[]}pointAt(t){return this.line.pointAt(t)}pointAtLength(t){return this.line.pointAtLength(t)}tangentAt(t){return this.line.tangentAt(t)}tangentAtLength(t){return this.line.tangentAtLength(t)}isDifferentiable(){return this.previousSegment==null?!1:!this.start.equals(this.end)}clone(){return new J(this.end)}scale(t,e,n){return this.end.scale(t,e,n),this}rotate(t,e){return this.end.rotate(t,e),this}translate(t,e){return typeof t=="number"?this.end.translate(t,e):this.end.translate(t),this}equals(t){return this.type===t.type&&this.start.equals(t.start)&&this.end.equals(t.end)}toJSON(){return{type:this.type,start:this.start.toJSON(),end:this.end.toJSON()}}serialize(){const t=this.end;return`${this.type} ${t.x} ${t.y}`}}(function(d){function t(...e){const n=e.length,s=e[0];if(w.isLine(s))return new d(s);if(g.isPointLike(s))return n===1?new d(s):e.map(r=>new d(r));if(n===2)return new d(+e[0],+e[1]);const i=[];for(let r=0;r<n;r+=2){const o=+e[r],c=+e[r+1];i.push(new d(o,c))}return i}d.create=t})(J||(J={}));class _ extends et{get end(){if(!this.subpathStartSegment)throw new Error("Missing subpath start segment. (This segment needs a subpath start segment (e.g. MoveTo), or segment has not yet been added to a path.)");return this.subpathStartSegment.end}get type(){return"Z"}get line(){return new w(this.start,this.end)}bbox(){return this.line.bbox()}closestPoint(t){return this.line.closestPoint(t)}closestPointLength(t){return this.line.closestPointLength(t)}closestPointNormalizedLength(t){return this.line.closestPointNormalizedLength(t)}closestPointTangent(t){return this.line.closestPointTangent(t)}length(){return this.line.length()}divideAt(t){const e=this.line.divideAt(t);return[e[1].isDifferentiable()?new J(e[0]):this.clone(),new J(e[1])]}divideAtLength(t){const e=this.line.divideAtLength(t);return[e[1].isDifferentiable()?new J(e[0]):this.clone(),new J(e[1])]}getSubdivisions(){return[]}pointAt(t){return this.line.pointAt(t)}pointAtLength(t){return this.line.pointAtLength(t)}tangentAt(t){return this.line.tangentAt(t)}tangentAtLength(t){return this.line.tangentAtLength(t)}isDifferentiable(){return!this.previousSegment||!this.subpathStartSegment?!1:!this.start.equals(this.end)}scale(){return this}rotate(){return this}translate(){return this}equals(t){return this.type===t.type&&this.start.equals(t.start)&&this.end.equals(t.end)}clone(){return new _}toJSON(){return{type:this.type,start:this.start.toJSON(),end:this.end.toJSON()}}serialize(){return this.type}}(function(d){function t(){return new d}d.create=t})(_||(_={}));class tt extends et{constructor(t,e){super(),this.isVisible=!1,this.isSubpathStart=!0,w.isLine(t)||I.isCurve(t)?this.endPoint=t.end.clone().round(2):this.endPoint=g.create(t,e).round(2)}get start(){throw new Error("Illegal access. Moveto segments should not need a start property.")}get type(){return"M"}bbox(){return null}closestPoint(){return this.end.clone()}closestPointLength(){return 0}closestPointNormalizedLength(){return 0}closestPointT(){return 1}closestPointTangent(){return null}length(){return 0}lengthAtT(){return 0}divideAt(){return[this.clone(),this.clone()]}divideAtLength(){return[this.clone(),this.clone()]}getSubdivisions(){return[]}pointAt(){return this.end.clone()}pointAtLength(){return this.end.clone()}pointAtT(){return this.end.clone()}tangentAt(){return null}tangentAtLength(){return null}tangentAtT(){return null}isDifferentiable(){return!1}scale(t,e,n){return this.end.scale(t,e,n),this}rotate(t,e){return this.end.rotate(t,e),this}translate(t,e){return typeof t=="number"?this.end.translate(t,e):this.end.translate(t),this}clone(){return new tt(this.end)}equals(t){return this.type===t.type&&this.end.equals(t.end)}toJSON(){return{type:this.type,end:this.end.toJSON()}}serialize(){const t=this.end;return`${this.type} ${t.x} ${t.y}`}}(function(d){function t(...e){const n=e.length,s=e[0];if(w.isLine(s))return new d(s);if(I.isCurve(s))return new d(s);if(g.isPointLike(s)){if(n===1)return new d(s);const r=[];for(let o=0;o<n;o+=1)o===0?r.push(new d(e[o])):r.push(new J(e[o]));return r}if(n===2)return new d(+e[0],+e[1]);const i=[];for(let r=0;r<n;r+=2){const o=+e[r],c=+e[r+1];r===0?i.push(new d(o,c)):i.push(new J(o,c))}return i}d.create=t})(tt||(tt={}));class j extends et{constructor(t,e,n,s,i,r){super(),I.isCurve(t)?(this.controlPoint1=t.controlPoint1.clone().round(2),this.controlPoint2=t.controlPoint2.clone().round(2),this.endPoint=t.end.clone().round(2)):typeof t=="number"?(this.controlPoint1=new g(t,e).round(2),this.controlPoint2=new g(n,s).round(2),this.endPoint=new g(i,r).round(2)):(this.controlPoint1=g.create(t).round(2),this.controlPoint2=g.create(e).round(2),this.endPoint=g.create(n).round(2))}get type(){return"C"}get curve(){return new I(this.start,this.controlPoint1,this.controlPoint2,this.end)}bbox(){return this.curve.bbox()}closestPoint(t){return this.curve.closestPoint(t)}closestPointLength(t){return this.curve.closestPointLength(t)}closestPointNormalizedLength(t){return this.curve.closestPointNormalizedLength(t)}closestPointTangent(t){return this.curve.closestPointTangent(t)}length(){return this.curve.length()}divideAt(t,e={}){const n=this.curve.divideAt(t,e);return[new j(n[0]),new j(n[1])]}divideAtLength(t,e={}){const n=this.curve.divideAtLength(t,e);return[new j(n[0]),new j(n[1])]}divideAtT(t){const e=this.curve.divideAtT(t);return[new j(e[0]),new j(e[1])]}getSubdivisions(){return[]}pointAt(t){return this.curve.pointAt(t)}pointAtLength(t){return this.curve.pointAtLength(t)}tangentAt(t){return this.curve.tangentAt(t)}tangentAtLength(t){return this.curve.tangentAtLength(t)}isDifferentiable(){if(!this.previousSegment)return!1;const t=this.start,e=this.controlPoint1,n=this.controlPoint2,s=this.end;return!(t.equals(e)&&e.equals(n)&&n.equals(s))}scale(t,e,n){return this.controlPoint1.scale(t,e,n),this.controlPoint2.scale(t,e,n),this.end.scale(t,e,n),this}rotate(t,e){return this.controlPoint1.rotate(t,e),this.controlPoint2.rotate(t,e),this.end.rotate(t,e),this}translate(t,e){return typeof t=="number"?(this.controlPoint1.translate(t,e),this.controlPoint2.translate(t,e),this.end.translate(t,e)):(this.controlPoint1.translate(t),this.controlPoint2.translate(t),this.end.translate(t)),this}equals(t){return this.start.equals(t.start)&&this.end.equals(t.end)&&this.controlPoint1.equals(t.controlPoint1)&&this.controlPoint2.equals(t.controlPoint2)}clone(){return new j(this.controlPoint1,this.controlPoint2,this.end)}toJSON(){return{type:this.type,start:this.start.toJSON(),controlPoint1:this.controlPoint1.toJSON(),controlPoint2:this.controlPoint2.toJSON(),end:this.end.toJSON()}}serialize(){const t=this.controlPoint1,e=this.controlPoint2,n=this.end;return[this.type,t.x,t.y,e.x,e.y,n.x,n.y].join(" ")}}(function(d){function t(...e){const n=e.length,s=e[0];if(I.isCurve(s))return new d(s);if(g.isPointLike(s)){if(n===3)return new d(e[0],e[1],e[2]);const r=[];for(let o=0;o<n;o+=3)r.push(new d(e[o],e[o+1],e[o+2]));return r}if(n===6)return new d(e[0],e[1],e[2],e[3],e[4],e[5]);const i=[];for(let r=0;r<n;r+=6)i.push(new d(e[r],e[r+1],e[r+2],e[r+3],e[r+4],e[r+5]));return i}d.create=t})(j||(j={}));function it(d,t,e){return{x:d*Math.cos(e)-t*Math.sin(e),y:d*Math.sin(e)+t*Math.cos(e)}}function at(d,t,e,n,s,i){const r=.3333333333333333,o=2/3;return[r*d+o*e,r*t+o*n,r*s+o*e,r*i+o*n,s,i]}function ft(d,t,e,n,s,i,r,o,c,h){const a=Math.PI*120/180,u=Math.PI/180*(+s||0);let l=[],f,m,p,y,x;if(h)m=h[0],p=h[1],y=h[2],x=h[3];else{f=it(d,t,-u),d=f.x,t=f.y,f=it(o,c,-u),o=f.x,c=f.y;const z=(d-o)/2,E=(t-c)/2;let T=z*z/(e*e)+E*E/(n*n);T>1&&(T=Math.sqrt(T),e=T*e,n=T*n);const Z=e*e,Y=n*n,K=(i===r?-1:1)*Math.sqrt(Math.abs((Z*Y-Z*E*E-Y*z*z)/(Z*E*E+Y*z*z)));y=K*e*E/n+(d+o)/2,x=K*-n*z/e+(t+c)/2,m=Math.asin((t-x)/n),p=Math.asin((c-x)/n),m=d<y?Math.PI-m:m,p=o<y?Math.PI-p:p,m<0&&(m=Math.PI*2+m),p<0&&(p=Math.PI*2+p),r&&m>p&&(m-=Math.PI*2),!r&&p>m&&(p-=Math.PI*2)}let b=p-m;if(Math.abs(b)>a){const z=p,E=o,T=c;p=m+a*(r&&p>m?1:-1),o=y+e*Math.cos(p),c=x+n*Math.sin(p),l=ft(o,c,e,n,s,0,r,E,T,[p,z,y,x])}b=p-m;const P=Math.cos(m),v=Math.sin(m),S=Math.cos(p),N=Math.sin(p),C=Math.tan(b/4),R=4/3*(e*C),A=4/3*(n*C),O=[d,t],L=[d+R*v,t-A*P],V=[o+R*N,c-A*S],W=[o,c];if(L[0]=2*O[0]-L[0],L[1]=2*O[1]-L[1],h)return[L,V,W].concat(l);{l=[L,V,W].concat(l).join().split(",");const z=[],E=l.length;for(let T=0;T<E;T+=1)z[T]=T%2?it(+l[T-1],+l[T],u).y:it(+l[T],+l[T+1],u).x;return z}}function wt(d){if(!d)return null;const t=`	
\v\f\r \xA0\u1680\u180E\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200A\u202F\u205F\u3000\u2028\u2029`,e=new RegExp(`([a-z])[${t},]*((-?\\d*\\.?\\d*(?:e[\\-+]?\\d+)?[${t}]*,?[${t}]*)+)`,"ig"),n=new RegExp(`(-?\\d*\\.?\\d*(?:e[\\-+]?\\d+)?)[${t}]*,?[${t}]*`,"ig"),s={a:7,c:6,h:1,l:2,m:2,q:4,s:4,t:2,v:1,z:0},i=[];return d.replace(e,(r,o,c)=>{const h=[];let a=o.toLowerCase();c.replace(n,(l,f)=>(f&&h.push(+f),l)),a==="m"&&h.length>2&&(i.push([o,...h.splice(0,2)]),a="l",o=o==="m"?"l":"L");const u=s[a];for(;h.length>=u&&(i.push([o,...h.splice(0,u)]),!!u););return r}),i}function St(d){const t=wt(d);if(!t||!t.length)return[["M",0,0]];let e=0,n=0,s=0,i=0;const r=[];for(let o=0,c=t.length;o<c;o+=1){const h=[];r.push(h);const a=t[o],u=a[0];if(u!==u.toUpperCase())switch(h[0]=u.toUpperCase(),h[0]){case"A":h[1]=a[1],h[2]=a[2],h[3]=a[3],h[4]=a[4],h[5]=a[5],h[6]=+a[6]+e,h[7]=+a[7]+n;break;case"V":h[1]=+a[1]+n;break;case"H":h[1]=+a[1]+e;break;case"M":s=+a[1]+e,i=+a[2]+n;for(let l=1,f=a.length;l<f;l+=1)h[l]=+a[l]+(l%2?e:n);break;default:for(let l=1,f=a.length;l<f;l+=1)h[l]=+a[l]+(l%2?e:n);break}else for(let l=0,f=a.length;l<f;l+=1)h[l]=a[l];switch(h[0]){case"Z":e=+s,n=+i;break;case"H":e=h[1];break;case"V":n=h[1];break;case"M":s=h[h.length-2],i=h[h.length-1],e=h[h.length-2],n=h[h.length-1];break;default:e=h[h.length-2],n=h[h.length-1];break}}return r}function Pt(d){const t=St(d),e={x:0,y:0,bx:0,by:0,X:0,Y:0,qx:null,qy:null};function n(c,h,a){let u,l;if(!c)return["C",h.x,h.y,h.x,h.y,h.x,h.y];switch(c[0]in{T:1,Q:1}||(h.qx=null,h.qy=null),c[0]){case"M":h.X=c[1],h.Y=c[2];break;case"A":return parseFloat(c[1])===0||parseFloat(c[2])===0?["L",c[6],c[7]]:["C"].concat(ft.apply(0,[h.x,h.y].concat(c.slice(1))));case"S":return a==="C"||a==="S"?(u=h.x*2-h.bx,l=h.y*2-h.by):(u=h.x,l=h.y),["C",u,l].concat(c.slice(1));case"T":return a==="Q"||a==="T"?(h.qx=h.x*2-h.qx,h.qy=h.y*2-h.qy):(h.qx=h.x,h.qy=h.y),["C"].concat(at(h.x,h.y,h.qx,h.qy,c[1],c[2]));case"Q":return h.qx=c[1],h.qy=c[2],["C"].concat(at(h.x,h.y,c[1],c[2],c[3],c[4]));case"H":return["L"].concat(c[1],h.y);case"V":return["L"].concat(h.x,c[1])}return c}function s(c,h){if(c[h].length>7){c[h].shift();const a=c[h];for(;a.length;)i[h]="A",h+=1,c.splice(h,0,["C"].concat(a.splice(0,6)));c.splice(h,1),o=t.length}}const i=[];let r="",o=t.length;for(let c=0;c<o;c+=1){let h="";t[c]&&(h=t[c][0]),h!=="C"&&(i[c]=h,c>0&&(r=i[c-1])),t[c]=n(t[c],e,r),i[c]!=="A"&&h==="C"&&(i[c]="C"),s(t,c);const a=t[c],u=a.length;e.x=a[u-2],e.y=a[u-1],e.bx=parseFloat(a[u-4])||e.x,e.by=parseFloat(a[u-3])||e.y}return(!t[0][0]||t[0][0]!=="M")&&t.unshift(["M",0,0]),t}function gt(d){return Pt(d).map(t=>t.map(e=>typeof e=="string"?e:D.round(e,2))).join(",").split(",").join(" ")}class q extends F{constructor(t){if(super(),this.PRECISION=3,this.segments=[],Array.isArray(t))if(w.isLine(t[0])||I.isCurve(t[0])){let e=null;t.forEach((s,i)=>{i===0&&this.appendSegment(q.createSegment("M",s.start)),e!=null&&!e.end.equals(s.start)&&this.appendSegment(q.createSegment("M",s.start)),w.isLine(s)?this.appendSegment(q.createSegment("L",s.end)):I.isCurve(s)&&this.appendSegment(q.createSegment("C",s.controlPoint1,s.controlPoint2,s.end)),e=s})}else t.forEach(n=>{n.isSegment&&this.appendSegment(n)});else t!=null&&(w.isLine(t)?(this.appendSegment(q.createSegment("M",t.start)),this.appendSegment(q.createSegment("L",t.end))):I.isCurve(t)?(this.appendSegment(q.createSegment("M",t.start)),this.appendSegment(q.createSegment("C",t.controlPoint1,t.controlPoint2,t.end))):$.isPolyline(t)?t.points&&t.points.length&&t.points.forEach((e,n)=>{const s=n===0?q.createSegment("M",e):q.createSegment("L",e);this.appendSegment(s)}):t.isSegment&&this.appendSegment(t))}get start(){const t=this.segments,e=t.length;if(e===0)return null;for(let n=0;n<e;n+=1){const s=t[n];if(s.isVisible)return s.start}return t[e-1].end}get end(){const t=this.segments,e=t.length;if(e===0)return null;for(let n=e-1;n>=0;n-=1){const s=t[n];if(s.isVisible)return s.end}return t[e-1].end}moveTo(...t){return this.appendSegment(tt.create.call(null,...t))}lineTo(...t){return this.appendSegment(J.create.call(null,...t))}curveTo(...t){return this.appendSegment(j.create.call(null,...t))}arcTo(t,e,n,s,i,r,o){const c=this.end||new g,h=typeof r=="number"?rt(c.x,c.y,t,e,n,s,i,r,o):rt(c.x,c.y,t,e,n,s,i,r.x,r.y);if(h!=null)for(let a=0,u=h.length;a<u;a+=6)this.curveTo(h[a],h[a+1],h[a+2],h[a+3],h[a+4],h[a+5]);return this}quadTo(t,e,n,s){const i=this.end||new g,r=["M",i.x,i.y];if(typeof t=="number")r.push("Q",t,e,n,s);else{const c=e;r.push("Q",t.x,t.y,c.x,c.y)}const o=q.parse(r.join(" "));return this.appendSegment(o.segments.slice(1)),this}close(){return this.appendSegment(_.create())}drawPoints(t,e={}){const n=dt(t,e),s=q.parse(n);s&&s.segments&&this.appendSegment(s.segments)}bbox(){const t=this.segments,e=t.length;if(e===0)return null;let n;for(let i=0;i<e;i+=1){const r=t[i];if(r.isVisible){const o=r.bbox();o!=null&&(n=n?n.union(o):o)}}if(n!=null)return n;const s=t[e-1];return new M(s.end.x,s.end.y,0,0)}appendSegment(t){const e=this.segments.length;let n=e!==0?this.segments[e-1]:null,s;const i=null;if(Array.isArray(t))for(let r=0,o=t.length;r<o;r+=1){const c=t[r];s=this.prepareSegment(c,n,i),this.segments.push(s),n=s}else t!=null&&t.isSegment&&(s=this.prepareSegment(t,n,i),this.segments.push(s));return this}insertSegment(t,e){const n=this.segments.length;if(t<0&&(t=n+t+1),t>n||t<0)throw new Error("Index out of range.");let s,i=null,r=null;if(n!==0&&(t>=1?(i=this.segments[t-1],r=i.nextSegment):(i=null,r=this.segments[0])),!Array.isArray(e))s=this.prepareSegment(e,i,r),this.segments.splice(t,0,s);else for(let o=0,c=e.length;o<c;o+=1){const h=e[o];s=this.prepareSegment(h,i,r),this.segments.splice(t+o,0,s),i=s}return this}removeSegment(t){const e=this.fixIndex(t),n=this.segments.splice(e,1)[0],s=n.previousSegment,i=n.nextSegment;return s&&(s.nextSegment=i),i&&(i.previousSegment=s),n.isSubpathStart&&i&&this.updateSubpathStartSegment(i),n}replaceSegment(t,e){const n=this.fixIndex(t);let s;const i=this.segments[n];let r=i.previousSegment;const o=i.nextSegment;let c=i.isSubpathStart;if(!Array.isArray(e))s=this.prepareSegment(e,r,o),this.segments.splice(n,1,s),c&&s.isSubpathStart&&(c=!1);else{this.segments.splice(t,1);for(let h=0,a=e.length;h<a;h+=1){const u=e[h];s=this.prepareSegment(u,r,o),this.segments.splice(t+h,0,s),r=s,c&&s.isSubpathStart&&(c=!1)}}c&&o&&this.updateSubpathStartSegment(o)}getSegment(t){const e=this.fixIndex(t);return this.segments[e]}fixIndex(t){const e=this.segments.length;if(e===0)throw new Error("Path has no segments.");let n=t;for(;n<0;)n=e+n;if(n>=e||n<0)throw new Error("Index out of range.");return n}segmentAt(t,e={}){const n=this.segmentIndexAt(t,e);return n?this.getSegment(n):null}segmentAtLength(t,e={}){const n=this.segmentIndexAtLength(t,e);return n?this.getSegment(n):null}segmentIndexAt(t,e={}){if(this.segments.length===0)return null;const n=D.clamp(t,0,1),s=this.getOptions(e),r=this.length(s)*n;return this.segmentIndexAtLength(r,s)}segmentIndexAtLength(t,e={}){const n=this.segments.length;if(n===0)return null;let s=!0;t<0&&(s=!1,t=-t);const i=this.getPrecision(e),r=this.getSubdivisions(e);let o=0,c=null;for(let h=0;h<n;h+=1){const a=s?h:n-1-h,u=this.segments[a],l=r[a],f=u.length({precision:i,subdivisions:l});if(u.isVisible){if(t<=o+f)return a;c=a}o+=f}return c}getSegmentSubdivisions(t={}){const e=this.getPrecision(t),n=[];for(let s=0,i=this.segments.length;s<i;s+=1){const o=this.segments[s].getSubdivisions({precision:e});n.push(o)}return n}updateSubpathStartSegment(t){let e=t.previousSegment,n=t;for(;n&&!n.isSubpathStart;)e!=null?n.subpathStartSegment=e.subpathStartSegment:n.subpathStartSegment=null,e=n,n=n.nextSegment}prepareSegment(t,e,n){t.previousSegment=e,t.nextSegment=n,e!=null&&(e.nextSegment=t),n!=null&&(n.previousSegment=t);let s=t;return t.isSubpathStart&&(t.subpathStartSegment=t,s=n),s!=null&&this.updateSubpathStartSegment(s),t}closestPoint(t,e={}){const n=this.closestPointT(t,e);return n?this.pointAtT(n):null}closestPointLength(t,e={}){const n=this.getOptions(e),s=this.closestPointT(t,n);return s?this.lengthAtT(s,n):0}closestPointNormalizedLength(t,e={}){const n=this.getOptions(e),s=this.closestPointLength(t,n);if(s===0)return 0;const i=this.length(n);return i===0?0:s/i}closestPointT(t,e={}){if(this.segments.length===0)return null;const n=this.getPrecision(e),s=this.getSubdivisions(e);let i,r=1/0;for(let o=0,c=this.segments.length;o<c;o+=1){const h=this.segments[o],a=s[o];if(h.isVisible){const u=h.closestPointT(t,{precision:n,subdivisions:a}),l=h.pointAtT(u),f=D.squaredLength(l,t);f<r&&(i={segmentIndex:o,value:u},r=f)}}return i||{segmentIndex:this.segments.length-1,value:1}}closestPointTangent(t,e={}){if(this.segments.length===0)return null;const n=this.getPrecision(e),s=this.getSubdivisions(e);let i,r=1/0;for(let o=0,c=this.segments.length;o<c;o+=1){const h=this.segments[o],a=s[o];if(h.isDifferentiable()){const u=h.closestPointT(t,{precision:n,subdivisions:a}),l=h.pointAtT(u),f=D.squaredLength(l,t);f<r&&(i=h.tangentAtT(u),r=f)}}return i||null}containsPoint(t,e={}){const n=this.toPolylines(e);if(!n)return!1;let s=0;for(let i=0,r=n.length;i<r;i+=1)n[i].containsPoint(t)&&(s+=1);return s%2===1}pointAt(t,e={}){if(this.segments.length===0)return null;if(t<=0)return this.start.clone();if(t>=1)return this.end.clone();const n=this.getOptions(e),i=this.length(n)*t;return this.pointAtLength(i,n)}pointAtLength(t,e={}){if(this.segments.length===0)return null;if(t===0)return this.start.clone();let n=!0;t<0&&(n=!1,t=-t);const s=this.getPrecision(e),i=this.getSubdivisions(e);let r,o=0;for(let h=0,a=this.segments.length;h<a;h+=1){const u=n?h:a-1-h,l=this.segments[u],f=i[u],m=l.length({precision:s,subdivisions:f});if(l.isVisible){if(t<=o+m)return l.pointAtLength((n?1:-1)*(t-o),{precision:s,subdivisions:f});r=l}o+=m}return r?n?r.end:r.start:this.segments[this.segments.length-1].end.clone()}pointAtT(t){const e=this.segments,n=e.length;if(n===0)return null;const s=t.segmentIndex;if(s<0)return e[0].pointAtT(0);if(s>=n)return e[n-1].pointAtT(1);const i=D.clamp(t.value,0,1);return e[s].pointAtT(i)}divideAt(t,e={}){if(this.segments.length===0)return null;const n=D.clamp(t,0,1),s=this.getOptions(e),r=this.length(s)*n;return this.divideAtLength(r,s)}divideAtLength(t,e={}){if(this.segments.length===0)return null;let n=!0;t<0&&(n=!1,t=-t);const s=this.getPrecision(e),i=this.getSubdivisions(e);let r=0,o,c,h,a,u;for(let S=0,N=this.segments.length;S<N;S+=1){const C=n?S:N-1-S,R=this.getSegment(C),A=i[C],O={precision:s,subdivisions:A},L=R.length(O);if(R.isDifferentiable()&&(h=R,a=C,t<=r+L)){c=C,o=R.divideAtLength((n?1:-1)*(t-r),O);break}r+=L}if(!h)return null;o||(c=a,u=n?1:0,o=h.divideAtT(u));const l=this.clone(),f=c;l.replaceSegment(f,o);const m=f;let p=f+1,y=f+2;o[0].isDifferentiable()||(l.removeSegment(m),p-=1,y-=1);const x=l.getSegment(p).start;l.insertSegment(p,q.createSegment("M",x)),y+=1,o[1].isDifferentiable()||(l.removeSegment(y-1),y-=1);const b=y-m-1;for(let S=y,N=l.segments.length;S<N;S+=1){const C=this.getSegment(S-b),R=l.getSegment(S);if(R.type==="Z"&&!C.subpathStartSegment.end.equals(R.subpathStartSegment.end)){const A=q.createSegment("L",C.end);l.replaceSegment(S,A)}}const P=new q(l.segments.slice(0,p)),v=new q(l.segments.slice(p));return[P,v]}intersectsWithLine(t,e={}){const n=this.toPolylines(e);if(n==null)return null;let s=null;for(let i=0,r=n.length;i<r;i+=1){const o=n[i],c=t.intersect(o);c&&(s==null&&(s=[]),Array.isArray(c)?s.push(...c):s.push(c))}return s}isDifferentiable(){for(let t=0,e=this.segments.length;t<e;t+=1)if(this.segments[t].isDifferentiable())return!0;return!1}isValid(){const t=this.segments;return t.length===0||t[0].type==="M"}length(t={}){if(this.segments.length===0)return 0;const e=this.getSubdivisions(t);let n=0;for(let s=0,i=this.segments.length;s<i;s+=1){const r=this.segments[s],o=e[s];n+=r.length({subdivisions:o})}return n}lengthAtT(t,e={}){const n=this.segments.length;if(n===0)return 0;let s=t.segmentIndex;if(s<0)return 0;let i=D.clamp(t.value,0,1);s>=n&&(s=n-1,i=1);const r=this.getPrecision(e),o=this.getSubdivisions(e);let c=0;for(let u=0;u<s;u+=1){const l=this.segments[u],f=o[u];c+=l.length({precision:r,subdivisions:f})}const h=this.segments[s],a=o[s];return c+=h.lengthAtT(i,{precision:r,subdivisions:a}),c}tangentAt(t,e={}){if(this.segments.length===0)return null;const n=D.clamp(t,0,1),s=this.getOptions(e),r=this.length(s)*n;return this.tangentAtLength(r,s)}tangentAtLength(t,e={}){if(this.segments.length===0)return null;let n=!0;t<0&&(n=!1,t=-t);const s=this.getPrecision(e),i=this.getSubdivisions(e);let r,o=0;for(let c=0,h=this.segments.length;c<h;c+=1){const a=n?c:h-1-c,u=this.segments[a],l=i[a],f=u.length({precision:s,subdivisions:l});if(u.isDifferentiable()){if(t<=o+f)return u.tangentAtLength((n?1:-1)*(t-o),{precision:s,subdivisions:l});r=u}o+=f}if(r){const c=n?1:0;return r.tangentAtT(c)}return null}tangentAtT(t){const e=this.segments.length;if(e===0)return null;const n=t.segmentIndex;if(n<0)return this.segments[0].tangentAtT(0);if(n>=e)return this.segments[e-1].tangentAtT(1);const s=D.clamp(t.value,0,1);return this.segments[n].tangentAtT(s)}getPrecision(t={}){return t.precision==null?this.PRECISION:t.precision}getSubdivisions(t={}){if(t.segmentSubdivisions==null){const e=this.getPrecision(t);return this.getSegmentSubdivisions({precision:e})}return t.segmentSubdivisions}getOptions(t={}){const e=this.getPrecision(t),n=this.getSubdivisions(t);return{precision:e,segmentSubdivisions:n}}toPoints(t={}){const e=this.segments,n=e.length;if(n===0)return null;const s=this.getSubdivisions(t),i=[];let r=[];for(let o=0;o<n;o+=1){const c=e[o];if(c.isVisible){const h=s[o];h.length>0?h.forEach(a=>r.push(a.start)):r.push(c.start)}else r.length>0&&(r.push(e[o-1].end),i.push(r),r=[])}return r.length>0&&(r.push(this.end),i.push(r)),i}toPolylines(t={}){const e=this.toPoints(t);return e?e.map(n=>new $(n)):null}scale(t,e,n){return this.segments.forEach(s=>s.scale(t,e,n)),this}rotate(t,e){return this.segments.forEach(n=>n.rotate(t,e)),this}translate(t,e){return typeof t=="number"?this.segments.forEach(n=>n.translate(t,e)):this.segments.forEach(n=>n.translate(t)),this}clone(){const t=new q;return this.segments.forEach(e=>t.appendSegment(e.clone())),t}equals(t){if(t==null)return!1;const e=this.segments,n=t.segments,s=e.length;if(n.length!==s)return!1;for(let i=0;i<s;i+=1){const r=e[i],o=n[i];if(r.type!==o.type||!r.equals(o))return!1}return!0}toJSON(){return this.segments.map(t=>t.toJSON())}serialize(){if(!this.isValid())throw new Error("Invalid path segments.");return this.segments.map(t=>t.serialize()).join(" ")}toString(){return this.serialize()}}(function(d){function t(e){return e!=null&&e instanceof d}d.isPath=t})(q||(q={}));(function(d){function t(n){if(!n)return new d;const s=new d,i=/(?:[a-zA-Z] *)(?:(?:-?\d+(?:\.\d+)?(?:e[-+]?\d+)? *,? *)|(?:-?\.\d+ *,? *))+|(?:[a-zA-Z] *)(?! |\d|-|\.)/g,r=d.normalize(n).match(i);if(r!=null)for(let o=0,c=r.length;o<c;o+=1){const h=r[o],a=/(?:[a-zA-Z])|(?:(?:-?\d+(?:\.\d+)?(?:e[-+]?\d+)?))|(?:(?:-?\.\d+))/g,u=h.match(a);if(u!=null){const l=u[0],f=u.slice(1).map(p=>+p),m=e.call(null,l,...f);s.appendSegment(m)}}return s}d.parse=t;function e(n,...s){if(n==="M")return tt.create.call(null,...s);if(n==="L")return J.create.call(null,...s);if(n==="C")return j.create.call(null,...s);if(n==="z"||n==="Z")return _.create();throw new Error(`Invalid path segment type "${n}"`)}d.createSegment=e})(q||(q={}));(function(d){d.normalize=gt,d.isValid=yt,d.drawArc=bt,d.drawPoints=dt,d.arcToCurves=rt})(q||(q={}));const At=Object.freeze(Object.defineProperty({__proto__:null,get Angle(){return k},get Point(){return g},get Line(){return w},get Ellipse(){return B},get Rectangle(){return M},get Path(){return q},Segment:et,normalizePathData:gt,get Curve(){return I},get Polyline(){return $},get GeometryUtil(){return D}},Symbol.toStringTag,{value:"Module"})),Lt=mt(At);export{Lt as r};
